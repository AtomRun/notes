# IOC和DI的雏形

还是拿上面的举例，有没有什么方法能够不使用工厂方法，也能实现OCP呢？也能让系统能运转呢？这就是IOC/DI的作用了。

## 这种形式没有HeroFactory如何得到ISkill呢？

假设有个容器或者什么直接获得iskill呢，这样就不需要使用HeroFactory了

# IOC的示例

1. 在没有IOC的时候，使用的都是工厂模式，只是工厂模式并没有彻底解决问题，但也在一定程度上达到了OCP
2. 即以前是直接去跟HeroFactory要对象，现在换成例如A依赖C，容器直接将C给A使用，控制的方向反转了，我们这里不用担心C是空值，容器的作用就是将C实例化，再将C给我们使用。方向是反向的。其实这里的C更多时候并不是一个具体的类，而是一个抽象，例如C继承的接口
3. 简单地说，以前A依赖C，现在A不再依赖C了，因为没有new的过程了

# 为什么引入容器让系统更稳定？

即正向和反向的区别，可以将系统想象为以下的四个类构成

![](https://i.loli.net/2020/08/18/i2QbTMI89hdHaYc.png)

这种情况下，假设某个类出现了问题，那么耦合度很强的情况下，系统会直接崩溃，但是，使用如下的容器方式就不一定了

![](https://i.loli.net/2020/08/18/7PgWU3GolLVaK6C.png)

容器就像是一个超大的齿轮，中间的齿轮会带动四周的转动，整个系统松耦合了。

# DIP是什么？

> DIP:依赖倒置

1. 高层模块不应该依赖低层模块，两者都应该依赖抽象||这里的高层指的是抽象，低层指的是细节
2. 抽象不应该依赖细节
3. 细节应该依赖抽象

# DI的意义

> 依赖注入

1. 属性注入
2. 构造注入
3. 接口注入

# DI的原理

# 容器的作用是在装配对象

A依赖C的相关方法，我们不需要考虑C，因为A依赖的并不是具体的C，而是一个C实现的接口，这样的话，我们每个类都是独立的，耦合性很低。

接口到时候是具体的哪个实例，由容器决定

# DI的角度来理解IOC

如果我们实例化一个对象，即A里实例化了一个C，那A就是主控类，但是我们使用了容器的话，主控就是容器。这个控制就反转了，交给容器去控制了。

# IOC的终极奥义

# @Component为什么能把被注解的类加入到容器中？

1. 注解是根据反射机制来实现的，通过反射读取注解的信息。

## Spring中如何知道要扫描@Component注解，为什么类上加了这个就会被加入到IOC容器中呢？

包括springBoot中只会扫描启动类的同级以下的注解

**使用了@ComponentScan这个注解来扫描包**