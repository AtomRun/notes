# 开闭原则

## 课程接口

```java
package com.leeup.design.priciple.openclose;

/**
 * @InterfaceName ICourse
 * @Description 开闭原则
 * @Author cLee
 * @Date{2020/3/16}
 * @Version 1.0
 **/
public interface ICourse {
    Integer getId();
    String getName();
    Double getPrice();
//    Double getDisCountPrice();
}

```

## 具体实现

```java
package com.leeup.design.priciple.openclose;

/**
 * @ClassName JavaCourse
 * @Description TODO
 * @Author cLee
 * @Date{2020/3/16}
 * @Version 1.0
 **/
public class JavaCourse implements ICourse{

    private Integer id;
    private String name;
    private Double price;

    public JavaCourse(Integer id, String name, Double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public Integer getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    public Double getPrice() {
        return this.price;
    }

    public Double getDisCountPrice() {
        return this.price * 0.8;
    }
}

```

## 测试类

```java
package com.leeup.design.priciple.openclose;

/**
 * @ClassName Test
 * @Description TODO
 * @Author cLee
 * @Date{2020/3/16}
 * @Version 1.0
 **/
public class Test {
    public static void main(String[] args) {
        // 接口引用指向实现类的对象
        ICourse javaCourse = new JavaCourse(96,"java电商开发",348d);
        System.out.println("课程ID"+javaCourse.getId()+"课程名称"+javaCourse.getName()+"课程价格"+javaCourse.getPrice());
    }
}
```

## 扩展

### 假设要开发一个打折活动，开发步骤如下

1. 在**ICourse**中添加一个新的打折接口**Double getDisCountPrice();**当前类肯定也要实现对应方法

```java
public Double getDisCountPrice() {
    return this.price * 0.8;
}
```

2. 直接Test中获取值即可

```java
public static void main(String[] args) {
    // 接口引用指向实现类的对象
    ICourse javaCourse = new JavaCourse(96,"java电商开发",348d);
    System.out.println("课程ID"+javaCourse.getId()+"课程名称"+javaCourse.getName()+"课程价格"+javaCourse.getDisCountPrice());
}
```

## 问题

我们修改了接口，并且类也进行了实现，但是如果类很多的话，我们都要进行重新实现，很麻烦。

并且，作为一个接口不应该进行经常性的变化，它应该是稳定且可靠的。

## 另一种思路

直接在getPrice*0.8

```java
public class JavaCourse implements ICourse{

    private Integer id;
    private String name;
    private Double price;

    public JavaCourse(Integer id, String name, Double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public Integer getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    public Double getPrice() {
        return this.price * 0.8;
    }
}
```

看起来好像很简单，只修改了一个类，但是如果有更复杂的逻辑，例如展示原价，还有要修改其他的课程实现类。

## 思考

如果通过扩展来实现javaCourse的子类JavaDiscount

```java
package com.leeup.design.priciple.openclose;

/**
 * @ClassName JavaDiscountCourse
 * @Description T0DO
 * @Author clee
 * @Date 2020/7/8 21:31
 * @Version 1.0
 **/
public class JavaDiscountCourse extends JavaCourse{

    public JavaDiscountCourse(Integer id, String name, Double price) {
        super(id, name, price);
    }

    @Override
    public Double getPrice() {
        return super.getPrice()*0.8;
    }
}

```

相应的Test就修改为

```java
public static void main(String[] args) {
    // 接口引用指向实现类的对象
    ICourse javaCourse = new JavaDiscountCourse(96,"java电商开发",348d);
    System.out.println("课程ID"+javaCourse.getId()+"课程名称"+javaCourse.getName()+"课程价格"+javaCourse.getPrice());
}
```

假设我们还想获取原价，去JavaCourseDiscount中加入代码

```java
public Double getOriginPrice(){
    return super.getPrice();
}
```

测试获取

```java
public static void main(String[] args) {
    // 接口引用指向实现类的对象
    ICourse ICourse = new JavaDiscountCourse(96,"java电商开发",348d);
    //获取原价
    //因为是父类声明的引用，所以无法获取子类的获取原价的方法，我们使用强转的方式
    JavaDiscountCourse javaCourse = (JavaDiscountCourse)ICourse;
    System.out.println("课程ID"+javaCourse.getId()+"课程名称"+javaCourse.getName()+"课程原价格"+javaCourse.getOriginPrice()+"课程价格"+javaCourse.getPrice());
}
```

