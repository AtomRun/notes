# Socket编程（四）

## 流协议与粘包

TCP是基于字节流的传输服务，这意味着，TCP传输的数据是没有边界的，因为无法区分字节流的边界，即无边界。

UDP基于消息的传输服务，他传输的数据报文，数据报，是有边界的。

有边界和无边界，反映在接收程序的时候不同，对于字节流来说，对等放接收数据不能保证一次操作能够返回多少个字节，是一个或者两个消息，这些是不确定的，也是粘包的原因。

比如主机A向主机B发送两个数据包M1和M2，对于主机B来说可能有以下情况，主机B一次读操作，返回数据的M1，第二次读操作返回M2，这样就没有粘包问题。

或者一次读操作返回了M1和M2的所有，M1和M2粘在一起了，这就是粘包问题。

或者一次读返回了M1和M2的一部分，第二次返回了M2的剩余部分

或者一次读返回了M1的一部分第二次返回了M1的一部分和M2

## 粘包产生的原因

![](https://i.loli.net/2020/05/09/FekI72T54L3EGC9.png)

![](https://i.loli.net/2020/05/09/5Jl3nSZ2jBm7Ofc.png)

## 粘包处理方案

- 本质上是要在应用层维护消息与消息的边界
- 定长包
- 包尾加\r\n (ftp)
- 包头加上包体长度
- 更复杂的应用层协议

![](https://i.loli.net/2020/05/09/C71uingYHBZOaTb.png)

## readn

![](https://i.loli.net/2020/05/09/FAHYtr4bE9PVe1W.png)

## writen

## 回射客户/服务器



