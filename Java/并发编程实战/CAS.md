# CAS

> compare and swap 比较&交换

![](https://i.loli.net/2020/10/09/DQuSANy4X5cWYHw.png)

**没有锁的状态下，保证多个线程对一个值的更新**

## ABA问题

我们读取一个值，值为0，修改为1后放回，但是值被线程2修改为1后，可能又被修改为0或者被其他线程又修改为0了，这个时候就是A-B-A，这就是A的值改为了B又改回了A

## 如何解决？

1. 加一个版本号，每次判断值是否与之前的相等，都判断版本号
2. 使用boolean类型判断，修改过为false之类的

## CAS的操作是在JVM中进行的

# 对象在内存中的布局

![](https://i.loli.net/2020/10/09/jW4a5LNg8frvpIY.png)

**markword+class pointer=对象头**

## classpointer

该对象属于哪个类，是一个指针

## 实例数据

1. 该对象假设有一个int类型数据，4字节
2. 一个long数据，8字节

## 对齐padding

1. 当我们整体字节数不能被8整除，我们就会补齐，补成能被8整除，被8整除会效率更快

## useCompressedClassPointers

使用压缩指针，假设JVM是64位的，指针的长度就应该是8字节，但是如果开启了压缩指针，会将指针的大小压缩成4个字节。

# 上锁的过程

## 锁升级

锁每次升级被markword记录

1. new->偏向锁->轻量级锁（无锁、自旋锁、自适应自旋）->重量级锁

