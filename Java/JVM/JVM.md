# JVM

## JVM结构

### 根据java -version来初识JVM

 ```shell
λ java -version                
   java version "1.8.0_172"     #java版本号                         
   Java(TM) SE Runtime Environment (build 1.8.0_172-b11)   #java开发环境信息
   Java HotSpot(TM) 64-Bit Server VM (build 25.172-b11, mixed mode)   #Hotspot/Server 
   
   # 1. HotSpot:JVM的核心组件或者说是JVM的名称，JDK每次在版本更新的时候，都会在侧重优化一个问题，进一步提升JVM的运行效率，这个运行效率是指对Class文件的解析运行效率，
   # 2. 在JDK1.3之前还不是HotSpot，那时候它的运行字节码文件的策略是，当运行Class之前，前面通过层层环叠的ClassLoader操作将类加载到 虚拟机 中，但是Class文件是一个中间层文件，他不属于CPU能直接解释的文件，虚拟机需要将Class文件再编译成NativeCode，也就是本地代码，就是CPU能够直接运行或者处理的代码。
   # 3. 意味着每次加载进来的Class,JVM都要对它进行转换，转换的频率越多，消耗的性能越大，在1.3之后。引入了核心技术的VM，HotSpotVM
   # 4. 当时使用了一个很先进的方法来解决这个问题，就是热点探测，就是每次虚拟机加载Class文件时，我会根据你加载的Class文件做标记，然后这个标记的过程，达到一定的阀值，会出发一个机制，叫做JIT(just in time),即时编译，会对频繁使用的Class文件，直接编译成本地代码，缓存起来，不再进行编译了。当这个常用类编译好的代码放到缓存中，下次用到直接去拿，少了一个编译的环节
   # 5. Server:其实JVM虚拟机在启动时，给我们准备了两个版本，一个时Client,一个是Server。其实他们是一个虚拟机，只是采用了两种不同的机制，来初始化自己。Client为更多的做桌面级应用而提供的虚拟机，他更多的是基于桌面级应用，这样的程序对他的内存空间做的优化。Client最大的特点就是，他知道桌面级的操作系统，JVM要在处理的代码量并不大，因为CS架构的应用按钮一次最多触发一次，也就是说程序和JVM交互的频率，相对于BS结构来说，频率要低很多。因为在BS中，是要处理并发的，那么JVM处理的线程数要多很多。所以为了更合理的使用内存，在Client版本中，他把内存分配的空间，相比Server版本缩小了很多。比如将堆中的内存就分配了10M，100M，回收对象时耗费的时间是0.xx秒，如果是Server端分配的会大很多
   # 6. JVM默认启动的是Client端，想要修改，进入JDK安装目录jre/lib/i386/JVM.cfg 修改里面的Client和Server的顺序，将Server放到上层即可
   # 7. Server端的缺点，空间浪费，如果使用不了那么多空间，就会浪费
 ```

## JVM总体结构

![20200424184403.png](https://i.loli.net/2020/04/24/SlguziqJMBnw2Nc.png)

**类加载子系统与方法区 **：**类加载子系统负责从文件或者网络中加载Class**[也就是说ClassLoader是我们这个系统下的组件，其实加载进来不是直接就运行了，要经过很多个模块的处理，比如文件的校验，HotsPot的处理]**，加载类的信息存放于一块称为方法区的内存空间**[ClassLoader通过文件将我们Class文件中的字节加载到虚拟机中，保存起来，那么我们Class中的字节就会放到这个方法区中]。除了类的信息外，方法区中可能还会存放运行时的常量池信息，包括字符串字面量和数字常量(这部分常量信息是Class文件中常量池部分的内存映射)

**总结** ：类加载子系统/方法区 这两块的能力就是通过类加载子系统将Class文件加载进来放到方法区内，并且将其中的常量也都存入方法区，或者说方法区中存入的都是唯一的东西/一份的东西

**[重点]Java堆：** java堆在虚拟机启动时就建立，他是java程序最主要的内存工作区域，几乎所有的java对象实例都会存储在java堆中，堆空间是所有线程共享的，这是一块与java应用密切相关的内存空间

**直接内存：** java的NIO库允许java程序使用直接内存，直接内存是java堆外的直接向系统申请的内存空间。通常访问内存的速度会优于java堆，因此处于性能的考虑，读写频繁的场合可能会考虑使用直接内存，由于直接内存在java堆外，因此它的大小不会受限与Xmx指定的最大堆大小，但是系统内存是有限的，java的堆和直接内存的综合，依然受限于操作系统能够给出的最大内存。

1. **总结：** 其实直接内存并不隶属于java堆的范畴，也就是说他不是被java堆所包含的，java堆的大小是由JVM来控制的，而直接内存是直接映射到物理内存上的，也就是说它理论上的空间是无限的，不受JVM的控制，它的大小限制，取决于你的物理内存的大小。

1. **[重点]垃圾回收系统：** 垃圾回收系统是java虚拟机的重要组成部分，垃圾收集器可以对方法区，java堆和直接内存进行回收[它并不只局限于回收java堆，对于方法区和直接内存也是可以回收的]。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的[对于程序员来说，内存中的管理和释放，都是不透明的]，也就是说，java中没有类似free()或者delete()函数。对于不再使用的垃圾对象，垃圾回收系统会在后台默默的工作，默默查找，标识并且释放垃圾对象，完成包括java堆、方法区和直接内存中的全自动化管理

2. **java栈** ：每个java虚拟机线程都有私有的java栈，一个线程的java栈在线程创建的时候创建，java栈中保留着帧信息，java栈中保存着局部变量，方法参数，同时和java方法的调用，返回密切相关，

3. **本地方法栈：** 本地方法栈和java栈非常类似，最大的不同用于于java方法栈用于JVM方法的调用，而本地方法栈则用于本地方法的调用[本地方法NativeMethod]，作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法(通常使用C编写)

   1. 总结：虚拟机在运行一些内容的时候，其实他有些东西脱离不了操作系统的内容，所以它可能仍然需要调用操作系统的API，那么他在调用操作系统的API在JVM中就被称为本地方法。为什么不同的操作系统提供了不同的版本的JVM，就是因为这块不通用，不同操作系统的结构或者API是不同的，所以他为了能够适用所有的操作系统，那就得写多个虚拟机调用不同的虚拟机中的不同的本地方法

4. **PC寄存器：** PC寄存器是每一个线程的私有空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个java线程总是在执行一个方法[线程没有不执行方法的时候，如果不执行方法，那么这个线程就会死掉]，这个方法被称为当前方法，如果当前方法不是本地方法，PC寄存器就会执行当前正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined。

   1. **总结 PC寄存器更多是来区分线程里执行的方法是本地方法还是你的java的自己的方法的作用**

5. **执行引擎：** 执行引擎是java中最核心的组件，它负责执行虚拟机的字节码，现代虚拟机为了提高执行效率，会使用即时编译(just in time)技术将方法编译成机器码后再执行。[上面说的HotSpot就是VM的执行器，它和数据库的引擎是类似的含义/概念]

 **2. JVM堆结构图及分代**

  1. **java虚拟机：JVM内存分代策略**

       1. java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代，老年代，永久代(对HotSpot而言)，这就是JVM的内存分代策略。[也就是说，我们现在看到的堆内部所划分的颗粒度会更细]

  2. **为什么要分代？**

       1. 堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中，给堆内存分代是为了提高对象内存分配和垃圾回收的效率，试想一下，[如果堆是一块内存，在这个内存中存所有的对象，而且每个对象的生命周期不同，比如有的就是朝生夕死的，有的是永久存活，有的是介于两者之间，如果把这些塞到同一内存中，对于垃圾回收来说，难度会大大提升，再就是，由于内存空间在存放对象的时候，他是连续的，这就意味着未来要在连续的内存中挑选不同的对象做回收，对内存空间做释放，这就意味着内存空间中会产生大量的碎片，产生碎片会带来的最直接的影响就是会对内存的空间造成浪费。例如原来这一块内存是200k,200k,200k，三块，结果中间的对象被回收了，那么这块就会被释放，空了200k,现在往里面存一个新的对象300k，存不进去，应该存到两个连续空的200k,200k中，那只能往后找有没有连续的空的200k,这个200k就浪费了。除非有小于200k的对象能利用上] 如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁的进行垃圾收集，而每次垃圾回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率。
      2. 有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代，静态属性、类信息等放在永久代中，新生代中的对象存活时间短，只需要在新生代区域频繁进行GC，老年代中生命周期长，内存回收频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾回收算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。

   3. **内存分代划分**

        1. java虚拟机将堆内存划分到 新生代、老年代、永久代，永久代是HotSpot虚拟机特有的概念，它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，而且HoSpot也有取消永久代的趋势，在JDK1.7中HotSpot已经开始“去永久化”，**把原来放在永久代的字符串常量池移出到方法区**，永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。堆内存分代示意图如下
      2. ![20200424184427.png](https://i.loli.net/2020/04/24/OxG5qRvthne2VFT.png)
3. 
   
    1. Eden[伊甸园]、From[]、To[][这两个统称为Survivor Spaces 幸存区域，这部分区域有人叫Survivor0 Survivor1，S0 S1，FromTo],这三个统称为年轻代，Old[老年代]，Permanetn[永久代]
          2. Eden[伊甸园，对象所有的出生，是在这里体现的，它是大部分对象的初始化和创建位置，有的对象运行完了就没什么事了，那么就会从Eden中把这个对象回收掉，所以这这些区域划分中，Eden区的垃圾回收次数频率是最高的，而且在Eden区中可以回收到整个区域的的80%以上的空间，唯独剩下的一部分对象，会被放在Survivor Spaces中，再来进一步判断是否需要回收，如果有没有被回收，就把它放在Old区域]
          3. [不同的区域，回收的频率不同，那么所采用的收集器也不用，收集器不仅仅是对堆进行回收，它细化到对堆里的不同的区域进行回收，也就是说年轻代可以指定一个垃圾回收器，而老年代和永久代指定一个垃圾回收器，他并不是对一个堆用一个垃圾回收器而是，对一个堆用不同的垃圾回收器。根据分代区域划分，这个过程叫做分代垃圾收集。]
      4. **新生代[Young Generation]**
    1. 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾回收一般可以回收70%-95%的空间，回收率很高
          2. HotSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1[因为大部分对象都在Eden中被清除掉了，所以From和To分的空间并不大，以免造成浪费]。划分的目的是因为HotSpot采用复制算法来回收新生代，设置这个比例是为了充分利用空间，以免造成浪费，新生成的对象在Eden区域分配(大对象除外，大对象直接进入老年代)，当Eden区没有足够的空间进行分配时，虚拟机将进行一次Minor GC[收集器分为两种，一种是次收集器，一种是全收集器，其实Minor GC就是去收集Eden区里的收集器，也就是回收年轻代的收集器]。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的(作为保留区)，GC进行时，Eden区中所有的存活对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值去决定去向，年龄值达到年龄阀值(默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1，GC分代年龄存储在对象的header中)的对象会被移动到老年代中，没有达到阀值得对象会被复制到To Survivor。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着From Survivor区和To Survivor区会交换它们得角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor。总之，不管怎么样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存货对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。
          3. 以上新生代的作用就是来筛选/检测对象使用频率是否会被GC回收，能否进入老年代
      5. **老年代[Old Generation]**
      
    1. 在新生代中经历了多次(具体看虚拟机配置的阀值)GC后仍然存活下来的对象会进入老年代中，老年代中的对象生命周期较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也会较慢[如果还对他频繁收集，第一无用，第二会降低虚拟机的性能，所以没有必要做高频繁的垃圾回收]
      6. **永久代[Permanent** Generation**]在jdk1.8之前，永久代即方法区，jdk1.8之后，永久代说法彻底消失，取而代之的是“元空间” ****Metaspace，元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。，理论上取决于32位/64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数。**

      7. 常用配置参数
  8. MetaspaceSize
           1. 初始化的Metaspace大小，控制元空间发生GC的阈值。GC后，动态增加或降低MetaspaceSize。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。使用[Java](http://lib.csdn.net/base/javase) -XX:+PrintFlagsInitial命令查看本机的初始化参数
  9. MaxMetaspaceSize
     
           1. 限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为4294967295B（大约4096MB）。
        10. MinMetaspaceFreeRatio
          
     1. 当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数（即实际非空闲占比过大，内存不够用），那么虚拟机将增长Metaspace的大小。默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。
        11. MaxMetasaceFreeRatio
     
      1. 当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。默认值为70，也就是70%。
        12. MaxMetaspaceExpansion
     
      1. Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。
        13. MinMetaspaceExpansion
     
      1. Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。
       14. **永久代存储类信息、常量、静态变量、即时编译后的代码等数据，对这一区域而言，java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收**

 

  **JVM垃圾回收算法及收集器**

  **1. 垃圾回收常见算法**

1. 

    1. **引用计数[reference Counting]**  
         1. 比较古老的回收算法，原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数，垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。[即对象刚创建出来，有引用了+1，有新的引用就+1，少了一个引用即-1，即做了一个计数器，来保证是否能回收，但是循环引用很难解决]
    
    2. **复制[Copying] **
    
         1. 此算法把内存空间划分为两个相等的区域，每次只是用其中一个区域，垃圾回收时。遍历当前使用区域，把正在使用的对象复制到另外一个区域中，此算法每次只能处理使用中的对象，因此复制成本比较小，同时复制过去后还能进行相应的内存整理，不会出现“碎片”问题，当然，此算法的缺点是很明显的，就是需要两倍内存空间
       2. ![](https://i.loli.net/2020/04/24/94gCSuvx6haHXV8.png)
       3. Before GC 上图橘色区域：空白的区域。橘色左边的区域，是引用区域，引用区域被分为，需要被复制的、需要被回收、没有被占用的空间，其中绿色是需要被复制的对象，蓝色是空的空间，灰色是即将被回收的对象，左边的会被清空，变成橘色
    
    3. **标记清除法[重点][Mark-Sweep]，JVM中做垃圾回收最古老的算法，后续所有的垃圾回收算法，其实都是围绕标记清除法做的延申/提升**
    
         1. 此算法分为两个阶段。第一阶段从引用根节点开始标记所有被引用的对象[从这个对象创建的根开始，为它以及它关联的属性做标记]，第二阶段遍历整个堆，把未标记的对象清除[如果某些对象没有做标记，说明这个对象可能是一个空对象，因为只要有标记的，说明有引用指向，说明这个对象正在被使用，如果没有被标记，即没有被引用，就会被回收]，此算法需要暂停整个应用[他在对对象做回收的时候，所有的用户线程都要停止，不能我们垃圾回收的时候，再向堆里放对象，这样的话，就不知道放进来的对象需不需要回收，我们后续所有的垃圾回收算法其实都是为了解决这个需要暂停这个环节的优化]，同时会产生内存碎片。
       2.![](https://i.loli.net/2020/04/24/89Gn1NAqEViwjxv.png)
    
    4. **标记整理算法[Mark-Compact]**
    
         1. 此算法结合了“标记-清除” 和 “复制” 两个算法的优点。也是分两个阶段，第一阶段从根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把清除未标记对象并且把存活的对象“压缩到堆中的其中一块”。按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制算法”空间的问题
       2. ![](https://i.loli.net/2020/04/24/QsYD2kapiFCLWZA.png)

  **2. JVM中的垃圾收集器**

    1. Scavenge GC(次收集) 和 Full GC 的区别(全收集)
    
         1. 新生代GC(Scavenge GC)：ScavengeGC 指发生在新生代的GC,因为新生代的java对象大多是朝生夕死，所以Scavenge GC非常频繁，一般回收速度也很快，当Eden空间不足为对象分配空间的时候，会触发Scavenge GC。
            1. 一般情况下，当新对象生成时，并且在Eden申请空间失败的时候，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对新生代的Eden区进行，不会影响到老年代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要速度快，高效率的算法，使Eden区能够尽快的空闲出来
    
       1. 老年代GC(Full GC/Major GC)：Full GC是指发生在老年代的GC,出现了Full GC一般会伴随着至少一次的Minor GC(老年代的对象大部分是Minor GC过程中从新生代进入老年代)，比如：分配担保失败。Full GC的速度一般会比Minor GC慢10倍以上。当老年代内存不足或者显式调用System.gc()方法时，会触发Full GC。
    
       2. 次收集
    
            1. 当年轻代堆空间紧张时会被触发，相对于全收集而言，收集间隔较短
    
       3. 全收集
    
            1. 当老年代或者持久代堆空间满了，会触发全收集操作，可以使用System.gc()[不是立即启动，而是优先启动]方法来显式的启动全收集，全收集一般根据堆大小的不同，需要的时间不尽相同，但一般会比较长，不过，如果全收集时间超过3-5秒钟，那就太长了

 



  **3. 分代垃圾收集器**

  1. **新生代收集器**

       1. **串行收集器(对Serial)**

            1. JDK1.3版本之前的JVM当中的唯一可选的收集器，在次代收集器中，那个时候之后只有一个次代收集器就是Serial，他是一个串行收集器，他的特点就是实现了暂停应用进行垃圾回收，即没有标记的对象进行回收
            2. Serial收集器是HotSpot运行在Client模式下默认新生代收集器，它的特点是只用一个CPU/一条收集线程去完成GC工作，且在进行垃圾收集时必须暂停其他所有的工作线程("Stop the World" STW)。可以使用-XX:UseSerialGC打开
            3. ![](https://i.loli.net/2020/04/24/kjloxF7OUeAXgE1.png)
            4. 虽然是单线程收集，但它却简单高效，在VM管理内存不大的情况下(收集几十到一两百M的新生代)停顿时间完全可以控制在几十毫秒到一百毫秒内

     2. **并行收集器(ParNew)[对串行收集器的升级，在多核心情况下，并行收集器可能会优于串行收集器。并且缩短了暂停时间]**

        1.     1. ParNew收集器其实是前面的串行收集器的多线程版本，除使用多条线程进行GC外，包括Serial可用的控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial完全一样(也是VM启用CMS收集器-XX:UseConcMarkSweepGC的默认新生代收集器)
               ![](https://i.loli.net/2020/04/24/wjh6OpogTeSfXiu.png)
               3. 由于存在线程切换的开销，ParlNew在单CPU的环境比不上Serial,且在通过超线程技术实现的两个CPU环境也不能100%保证超越Serial，但随着可用的CPU增加，收集效率肯定也会大大的增加(ParlNew收集线程数与CPU数量相同，因此在CPU数量过大的环境中，可以使用-XX:ParallelGCThreads=<N 参数控制 GC 线程数)。ParNew是JVM中真正实现了让工作线程运作时缩短了安全点的时间

     3. **Parallel Scavenge 收集器**

          1. 与ParlNew类似 Parallel Scavenge也是使用复制算法，也是并行多线程收集器，但是他与其他收集器关注尽可能缩短垃圾收集的时间不同[它与parNew有一个关键的区别，ParNew是为了缩短安全点/应用暂停的时间，不想过长的占用线程的时间，但是Parallel Scavenge更多是为了解决系统吞吐量的问题，也就是当我们的收集器在运行时，可以节省更多的时间来提高CPU运行用户程序的吞吐量]，Parallel Scavenge更关注系统吞吐量：系统吞吐量=CPU运行用户程序时间/(CPU运行用户程序时间+GC收集时间),停顿时间越短就越适用于用户交互的程序-良好的响应速度能提升用户的体验，而高吞吐量则适用于后台运算而不需要太多交互的任务-可以高效率地利用CPU时间，尽快地完成程序的运算任务，Parallel Scavenge提供了如下参数设置系统吞吐量

          2. ![20200424185001.png](https://i.loli.net/2020/04/24/axEFvyDW7grhYuN.png)

             ![](https://i.loli.net/2020/04/24/yDI9uG3bfx1jYJK.png)

  2. **老年代收集器**

         1. Serial Old收集器
            1. Serial Old是Serial收集器的老年代版本，同样是单线程收集器，使用“标记整理”算法：Serial Old在运用到老年代的时候，不能使用复制算法了，因为老年代中没有两块区域供你复制
            2. ![](https://i.loli.net/2020/04/24/jUTkcJ2vzISQFOE.png)

     1. **Parallel Old收集器**

        1. Parallel Old是Parallel Scavange收集器的老年代版本，使用多线程和标记整理算法，吞吐量优先，主要与Parallel Scavange配合在注重吞吐量和CPU资源敏感的系统内使用
           1. ![](https://i.loli.net/2020/04/24/6BjPsbECHLxzN7p.png)

     2. **CMS收集器[并行和并发的区别：并行(就是当前的CPU在运行用户程序的时候，在停止当前用户程序的时候，我的GC可以以多线程的形式运行的，这个并行指的是GC的线程可以多线程的形式运行) 并发(我的GC线程和用户的工作线程交替运行)]**

        1. CMS(Concurrent Mark Sweep)是一款具有划时代意义的收集器，一款真正意义上的并发收集器，虽然现在已经有了理论上表现更好的G1收集器，但是现在主流互联网线上选用的仍然是CMS(如淘宝，微店)
           1. CMS是一种以获取最短回收停顿时间为目标的收集器(CMS又称为多并发低暂停的收集器)，基于“标记-清除”算法实现，整个GC分为以下4个步骤“：

        2. 1. **初始标记(CMS initial mark)**
           1. 并发标记(CMS concurrent mark:GC Roots Tracing 过程)
           2. **重新标记(CMS remark)**
           3. 并发清除(CMS concurrent sweep:已死对象会就地释放，注意：此处没有压缩)

        3. 其中两个加粗的步骤(初始/重新)仍需STW，但初始仅只标记一下 GC Roots能够直接关联到对象，速度很快。而重新标记则是为了修正并发标记期间因用户程序继续运行导致标记产生变动那一部分对象的标记记录，虽然一般比初始标记阶段稍长，但要远小于并发标记时间

        4. ![](https://i.loli.net/2020/04/24/DmPFvVJBLUHdeMg.png)

        5. CMS 默认启动的回收线程数=(CPU数目+3)4，当CPU数 4时,GC线程最多占用不超过25%的CPU资源，但是当CPU数量<4时，GC线程可能就会过多的占用用户CPU资源，从而导致应用程序变慢，总吞吐量降低

        6. 无法处理浮动垃圾，可能出现 *Promotion Failuure、Concurrent Mode Failure* 而导致另一次Full GC的产生：浮动垃圾是指在CMS并发清理阶段用户线程运行而产生的新垃圾，由于在GC阶段用户线程还需要运行，因此还需要预留足够的内存空间给用户线程使用，导致CMS不能像其他收集器那样等到老年代几乎填满了在进行收集，因此CMS提供了-XX:CMSInitiatingOccupancyFraction 参数来设置GC的触发百分比(以及-XX:+UseCMSInitiatingOccupancyOnly 来启用才触发百分比)但当CMS运行期间预留的内存无法满足程序需要，就会出现上述 Promotion Failure等失败，这时VM将启动后备预案：临时使用Serial Old收集器来重新执行Full GC(CMs通常配合大内存使用。一旦大内存转入串行的Serial GC那停顿的时间就是大家都不愿意看到的了)

        7. 最后，由于CMS采用"标记-清除"算法实现，可能会产生大量内存碎片，内存碎片过多可能会导致无法分配大对象而提前触发Full GC 因此CMS提供了-XX:UseCMSCompactAtFullCollection开关参数，用在Full GC后在执行一个碎片整理过程，但是内存整理是无法并发的，内存碎片问题虽然没有了，但是停顿时间也因此变长了，因此CMS还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction用于设置在执行N次不进行内存整理的Full GC后，跟着来一次带整理的(默认为0，每次进入Full GC时都进行碎片整理)

     3. **分区收集-G1收集器[并非默认的收集器]**

        1. *G1(Garbage-First)是一款面向服务端应用的收集器，主要目标用于配备多颗CPU的服务器治理大内存。G1 is planned as the long tern replacement for the Concurrent Mark-Sweep Collector(CMS) --XX:UseG1GC 启动G1收集器*
        2. 与其他基于分代的收集器不同，G1将整个Java堆划分为多个大小相等的独立区域(Region),虽然还保留有新生代和老年代的概念，但是新生代和老年代已经不再是物理隔离的了，它们都是一部分Region(不需要联系)的集合

        3. ![](https://i.loli.net/2020/04/24/pgz6ELFMV4Ww1Jy.png)

        4. 每块区域即可能是O区，也可能是Y区，因此不需要一次就对整个老年代/新生代回收，而是当线程并发寻找可回收的对象时，有些区块包含可回收的对象要比其他区块多很多，虽然清理这些区块时G1仍需要暂停应用线程，但是可以用相对较少的时间优先回收垃圾较多的Region(这也是G1命名的来源)，这种方式保证了G1可以在有限的时间内获取尽可能高的收集效率 

        5. ![](https://i.loli.net/2020/04/24/xk3mlGpeM48qOZj.png)

        6. G1的新生代收集跟ParNew类似：存活的对象被转移到一个/多个Survivor Regions。如果存活时间达到阀值，这部分对象会被提升到老年代

        7. ![](https://i.loli.net/2020/04/24/YwHQCieTIjopZXt.png)

        8. G1的新生代收集特点如下

           1. 一整块内存被分为多个Regions
           2. 存活的对象被拷贝到新的Survivor区域老年代
           3. 年轻代内存由以组不连续的heap区组成，这种方法使得可以动态调整各代区域尺寸
           4. Young GCs会有STW时间，进行时所有应用程序线程都会被暂停
           5. 多线程并发GC

        9. G1的老年代GC特点如下：

           1. 并发标记阶段(idnex3)
              1. 在与应用程序并发执行的过程会计算活跃度信息
             1. 这些活跃度信息标识出那些regions最适合在STW期间回收(*which regions will be best to reclaim during an evacuation pause*)
             2. 不像CMS有清理阶段

            1. 再次标记阶段(index4)

               1. 使用Snapshot-at-the-Beginning(SATB)算法比CMS快得多
              2. 空region直接被回收

            2. 拷贝/清理阶段(Copying/Cleanup phase)

               1. 年轻代与老年代同时回收
              3. 老年代内存回收会基于他的活跃度信息

 

  **JVM优化**

  **1. JVM小工具**

| bin       | 描述                                                         | 功能                                                         |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| jps       | 打印HotSpotVM进程                                            | VMID，JVM参数，Main()函数参数，主类名/jar路径                |
| jstat     | 查看HotSpotVM运行时信息                                      | 类加载，内存，GC[可分代查看]，JIT编译命令格式：jstat-gc 10340 250 20 |
| jinfo     | 查看和修改虚拟机各项配置                                     | -flag name=value                                             |
| jmap      | heapdump:生成VM堆转储快照，查询finalize 执行队列，java堆和永久代详细信息 | jmap-dump:live,format=b,file=heap.bin[VMID]                  |
| jstack    | 查看VM当前时刻的线程快照，当前VM内每一条线程正在执行的方法堆栈集合 | Thread.getAllStackTraces() 提供了类似的功能                  |
| javap     | 查看经javac之后产生的JVM字节码代码                           | 自动解析.class文件，避免了去理解class文件格式以及手动解析文件内容 |
| jcmd      | 一个多功能工具，可以用来导出堆，查看java进程，导出线程信息，执行GC，查看性能相关数据 | 几乎集合了jps,jstat,jinfo,jmap,jstack所有功能                |
| jconsole  | 基于JMX的可视化监视，管理工具                                | 可以查看内存，线程，类，CPU信息，以及堆JMXMBean进行管理      |
| jvisualvm | JDK中最强大的运行监视和故障处理工具                          | 可以监控内存泄露，跟踪垃圾回收，执行时内存分析，CPU分析，线程分析... |

  **2. JVM参数介绍[命令肯定是虚拟机启动时给定的，而不是运行时给定的，在eclipse中可以体现为run As- run Configurations- Arguments中填写参数]**

    1. 内存大小设置
    
         1. -Xms:初始堆大小 [包含了Eden、Old整个堆的大小，他会根据给定的大小分配年轻代，老年代，持久代]
       1. -Xmx:最大堆大小 [初始堆不够的时候，他会申请，最大能够申请的容量大小]
       2. -XX:NewSize=n:设置年轻代大小
       3. -XX:NewRatio=n:设置年轻代和老年代的比值。如：为3，表示年轻代和老年代的比值为1:3,年轻代占整个年轻代和老年代的1/4
       4. -XX:SurvivorRation=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden区：Survivor=3:2,一个Survivor区占整个年轻代的1/5
       5. -XX:MaxPermSize=n:设置持久代大小
    
    2. 收集器设置
    
         1. -XX:+UseSerialGC:设置串行收集器
       1. -XX:+UseParallelGC:设置并行收集器
       2. -XX:+UseParallelOldGC:设置并行老年代收集器
       3. -XX:+UseConcMarkSweepGC:设置并发收集器
       4. -XX:+UseG1GC:设置G1收集器
    
    3. 垃圾回收统计信息
    
         1. -XX:+PrintGC
       1. -XX:+Printetails
       2. -XX:PrintGCTimeStamps
       3. -XXloggc:filename

 



  **3. 常见配置举例**

    1. 堆大小设置
    
         1. JVM中最大堆大小有三方面限制：相关操作系统的数据模型(32bit-64bit)限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5g-2g;64位操作系统对内存无限制。我在Windows Server 2003系统内，3.5g物理内存，jdk5.0下测试，最大可设置位1487m。
       2. 典型设置 **j****ava -Xmx3550m -Xms3550m -Xmn2g -Xss128k**
    
       3. 1. -Xmx3550m:设置JVM最大可用内存为3550m
    
        2. -Xms3550m:设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存
    
        3. -Xmn2g:设置年轻代大小为2g。**整个堆大小=年轻代大小+老年代大小+持久代大小**。持久代一般固定大小为64m,所以增大年轻代后，将会减少老年代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
    
        4. -Xss128k：设置每个线程的堆栈大小。JDK5.0后每个线程堆栈大小为1M，以前每个线程堆栈大小为256k。更具应用的线程所需内存大小进行调整。在相同物理内存下，减少这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的。不能无限生成，经验值在3000-5000左右
    
        5. java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4
    
           1. -XX:SurvivorRatio=4 -XX:MaxPermiSize=16m
           2. -XX:MaxTenuringThreshold=0
           3. -XX:NewRatio=4:设置年轻代(包括Eden和两个Survivor区)与老年代的比值(除去持久代)。设置为4，则年轻代与老年代所占比值为1:4,年轻代占整个堆栈的1/5
           4. -XX:SurvivorRation=4:设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
           5. -XX:MaxPermSize=16m:设置持久代大小为16m
           6. -XX:MaxTenuringThreshold=0:设置垃圾最大年龄**，如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代**。对于年老带比较多的应用，可以提高效率。如果将此值设置为一个较大值，**则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间**，增加在年轻代即将被回收的概论
           7. 回收器选择JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。在默认情况下，JDK5.0以前都是使用串行收集器，如果是想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当系统配置进行判断
    
    2. 吞吐量优先的并行收集器
    
         1. 并行收集器主要以达到一定的吞吐量为目标，适用于科学技术和后台处理等
       1. 典型配置
    
            1. java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:+ParallelGCThreads=20
            2. 1. -XX:+UseParallelGC:选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，**年轻代使用并发收集，而老年代仍旧使用串行收集**
    
             1. -XX:ParallelGCThreads=20:配置并行收集器的线程数，即:同事多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。
    
             2. java-Xmx3550m-Xms3550m-Xmn2g-Xss128K -XX:＋UseParallelGC -XXParallelGCThreads＝20 **-XX:＋UseParalleloldGC** 
    
                1. **xx:＋UseParallelOldGC:**配置年老代垃圾收集方式为并行收集。JDK6.0持对年老代并行收集
    
             3. java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX＋UseParalleIGC-XX:MaxGCPauseMillis＝100
    
                1. **-XX:MaxGCPauseMillis＝100**:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。
    
             4. java-Xmx3550m-Xms3550m-Xmn2g-Xss128k
    
             5. -XX:＋UseParallelGC -XX:MaxGCPauseMillis＝100 **-XX:＋UseAdaptiveSizePolicy**
    
                1. **-XX:＋UseAdaptiveSizePolicy** 设置此选项后，并行收集器会自动选择年轻代区和大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。
                2. 响应时间优先的并行收集器如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间，适用于应用服务器、电信领域等

  **4. 调优总结**

    1. **年轻代大小选择**
    
         1. **响应时间优先的应用:**尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象
       2. **吞吐量优先的应用:**尽可能的设置大，可能到达Gbit的程度因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。
    
    2. **老年代大小选择**
    
         1. **响应时间优先的应用:**年老代使用并发集器，所以其大小需要小心设置，一般要考虑并发会话率和会持续时间等一些数如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得:
       2. 1. 并发垃圾收集信息
        2. 持久代并发收集次数
        3. 传统GC信息
        4. 花在年轻代和年老代回收上的时间比例,减少年轻代和年老代花费的时间，一般会提高应用的效率
    
       3. **吞吐量优先的应用:**一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象较小堆引起的碎片问题因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现碎片如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现碎片，可能需要进行如下配置：
    
            1. **-XX:+UseCMSCompactAtFullCollection:**使并发收集器时，开启对年老代的压缩。
            2. **-XX:CMSFulIGCsBeforeCompaction=0:**上面配置开启的情况下，这里设置多少FUGC后，对年老代进行压缩

  **Eclipse运行调优**

  **1. 安装jvisualvm Visual GC 插件**

  1. **命令行运行jvisualvm，在工具-插件中安装Visual GC插件**
  2. **通过插件查看eclipse启动**
  3. **修改eclipse配置提高启动速度**
  4. **-Xverify:none**

